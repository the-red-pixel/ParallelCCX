# SRFG-v1
> Stack Related Flow Graph (Revision 1)  
> 栈相关控制流图（第一修订版）  

**（阅读此文档前，请确定您已知晓 Java 字节码相关的基础知识）**


## 目录
- [1 概述](#1)
- [2 图结构](#2)
    - [2.1 基本表示](#2-1)
    - [2.2 基本单位](#2-2)
        - [2.2.1 指令节点](#2-2-1)
        - [2.2.2 逃逸节点](#2-2-2)
        - [2.2.3 栈消隐节点](#2-2-3)
        - [2.2.4 栈复位节点](#2-2-4)
        - [2.2.5 限位节点](#2-2-5)
    - [2.3 有序性](#2-3)
    - [2.4 非栈上联结逻辑](#2-4)
    - [2.5 跳转](#2-5)
- [3 图算法](#3)
    - [3.1 构建](#3-1)
        - [3.1.1 构建简单代码的 SRFG](#3-1-1)
        - [3.1.2 构建存在非栈上联结逻辑的代码的 SRFG](#3-1-2)
        - [3.1.3 构建存在跳转的代码的 SRFG](#3-1-3)
    - [3.2 遍历与还原](#3-2)
        - [3.2.1 简单 SRFG 的遍历与还原](#3-2-1)
        - [3.2.2 包含逃逸的 SRFG 的遍历与还原](#3-2-2)
        - [3.2.3 包含跳转的 SRFG 的遍历与还原](#3-2-3)
    - [3.3 修改](#3-3)
        - [3.3.1 逻辑限位](#3-3-1)


## <a id = "1">1&nbsp;概述</a>
&emsp;&emsp;**SRFG** 可基于代码的栈关系模型来建立、表示 Java 字节码的控制流。


## <a id = "2">2&nbsp;图结构</a>

### <a id = "2-1">2.1&nbsp;基本表示</a>
&emsp;&emsp;在 **SRFG** 中，最基本的单位是**节点**。 节点与节点之间可以使用**边**进行连结，这就是 **SRFG** 的最基本形式。每条边能且仅能连接两个节点，而每个节点可与多条边联结，与一般的图算
法相类似。  
&emsp;&emsp;基本结构如图 2-1 所示：
```
Graph 2-1:
    +--------+
    | Node 1 |
    +--------+
        |E1
    +--------+
    | Node 2 |
    +--------+
```
&emsp;&emsp;对于边 E1 来说，节点 N1 是它的**上节点**，节点 N2 是它的**下节点**。而对于节点 N1 来说，边 E1 是它的一条**下边**，对于节点 N2 来说，边 E1 是它的一条**上边**。没有**上边**与之连接的节点称为**首节点（Head node）**，没有**下边**与之连接的节点称为**末节点（Terminal node）**。  
&emsp;&emsp;在大部分情况下，节点与节点之间如果存在边将他们直接连接，则代表这两个节点在栈内存上存在关系，我们称它为**栈上联结**。一般情况下，上节点为**生产者**，即栈上的内容为上节点的操作结果或返回值，而下节点为**消费者**，即栈上的内容为下节点的操作数（Operand）。这样便就构成了一个最简单的**栈相关流（SRF）**，并且在一个控制流中第一个被构造的**栈相关流节点（SRF Node）**将被作为**栈相关流根节点（SRF Root）**。多个**栈相关流**同时存在的情况将在后续章节中讨论。  

### <a id = "2-2">2.2&nbsp;基本单位</a>
&emsp;&emsp;从上一节 [2.1](#2.1&nbsp基本表示) 中可知，**节点**即是 **SRFG** 的最基本的单位。本节将对 **SRFG** （仅针对此修订版）中的各种节点类型进行列举。  

#### <a id = "2-2-1">2.2.1&nbsp;指令节点</a>
&emsp;&emsp;**指令节点**即是包含着一条指令的相关信息的节点，其中包含了这条指令的机器码、类型、操作数以及其它的相关信息（信息存储、表示方式由具体的实现决定）。**指令节点**是 **SRFG** 的基本单位中的基本，因为 **SRFG** 就是被设计来用某种形式、联系来表示指令流的。如果一个 **SRFG** 中不存在任何一个**指令节点**，那么就可以断言它是没有意义的（暂不考虑对 **SRFG** 的后期修改）。  
&emsp;&emsp;一般地，**指令节点**都可以有一个或多个**上边**与多个**下边**与其直接连接，而这种连接就直接表示了栈上关系。而对于每个**指令节点**究竟可以连接几个**上边**与**下边**，则需要根据具体的指令及其相关信息来判断。

#### <a id = "2-2-2">2.2.2&nbsp;逃逸节点</a>
&emsp;&emsp;由于 **SRFG** 中，指令与指令之前的逻辑关系是根据栈的情况来连接的。而当两段指令之间不存在直接的栈上联系时，就无法用一般的**节点**之间直接连接的方式来表示两条或两端指令之间的逻辑联系。**逃逸节点**便就是为了解决此类问题的，更多关于**逃逸节点**的说明请见 [2.4 节](#2.4&nbsp;非栈上联结逻辑)，本节中不多作赘述。    

#### <a id = "2-2-3">2.2.3&nbsp;栈消隐节点</a>
&emsp;&emsp;在 **SRFG** 中，是以**块**作为跳转指令的目标的。**块**之间是不允许存在节点的直接连接的，而跳转时可能栈上还存在内容，并且这些内容还可能会被跳转之后的后续指令所使用。**栈消隐节点**便就是为了解决此类问题的，它可以记录、表示某一条跳转指令在跳转至其它**块**时的栈上内容的信息，并用于后续的 **SRFG** 构建及验证。有关**块**的定义以及更多关于**栈消隐节点**的说明请见 [2.5 节](#2.5&nbsp;跳转)，本节中不多作赘述。

#### <a id = "2-2-4">2.2.4&nbsp;栈复位节点</a>
&emsp;&emsp;在 **SRFG** 中，是以**块**作为跳转指令的目标的。**块**之间是不允许存在节点的直接连接的，而跳转之后的代码可能还需要使用跳转之前的栈上内容，并且 **SRFG** 仍可能需要这些信息来构建出正确的图及节点间的连接关系。**栈复位节点**便就是为了解决此类问题的。有关**块**的定义以及更多关于**栈消复位点**的说明请见 [2.5 节](#2.5&nbsp;跳转)，本节中不多作赘述。

#### <a id = "2-2-5">2.2.5&nbsp;限位节点</a>
&emsp;&emsp;详见 [3.3.1 节](#3-3-1)。

### <a id = "2-3">2.3&nbsp;有序性</a>
&emsp;&emsp;由于代码存在严格的有序性（不考虑编译器优化等情况），所以在 **SRFG** 中，为了简化操作，提升灵活性，并没有使用标记节点深度的方式来确定节点顺序。而此时，如果不用其它的信息来标记顺序，则可能会出现逻辑信息丢失的情况，如图 2-2 及代码段 2-1:
```
Bytecode 2-1:
    # iconst_1
    # iconst_0
    # invokestatic foo(II)V

Graph 2-2:
    +----------+  +----------+
    | iconst_1 |  | iconst_0 |
    +----------+  +----------+
         |             |
    +-----------------------+
    | invokestatic foo(II)V |
    +-----------------------+
```
&emsp;&emsp;仅凭图中的信息无法确定究竟 ```iconst_0``` 的结果是第一操作数，还是 ```iconst_1``` 的结果是第一操作数。所以对于每一个节点，与其相直接连接的**上边**都存在有序性，每一条连接的**上边**不仅有**栈上联结**意义，同时还存在有序性信息，在使用图算法对图进行操作时也应该考虑到有序性的意义。而此有序性信息仅对边的**下节点**或节点的**上边**有意义。  
&emsp;&emsp;在用直观图表示时应对边进行编号，如图 2-3：
```
Graph 2-3:
    +--------+  +--------+
    | Node 1 |  | Node 2 |
    +--------+  +--------+
        |0          |1
       +--------------+
       |    Node 2    |
       +--------------+
```
上文中的代码段即应如图 2-4 表示：
```
Bytecode 2-1:
    # iconst_1
    # iconst_0
    # invokestatic foo(II)V

Graph 2-4:
    +----------+  +----------+
    | iconst_1 |  | iconst_0 |
    +----------+  +----------+
         |0            |1
    +-----------------------+
    | invokestatic foo(II)V |
    +-----------------------+
```
或如图 2-5 表示：
```
Bytecode 2-1:
    # iconst_0
    # iconst_1
    # invokestatic foo(II)V

Graph 2-5:
    +----------+  +----------+
    | iconst_0 |  | iconst_1 |
    +----------+  +----------+
         |1            |0
    +-----------------------+
    | invokestatic foo(II)V |
    +-----------------------+
```

### <a id = "2-4">2.4&nbsp;非栈上联结逻辑</a>
&emsp;&emsp;在一些情况下，一段代码虽然在逻辑上是连续的，但是可能在栈上没有任何联系，就如下图中的代码段 2-2：
```
Bytecode 2-2:
    # iconst_0
    # iconst_m1
    # astore_1
    # astore_2
```
&emsp;&emsp;由于在 **SRFG** 中，节点之间的连接只考虑栈上关系，而代码段
```
# iconst_m1
# astore_1
```
与前文中的 ```iconst_0``` 无任何栈上联系，所以此处的代码逻辑就无法完全用栈的关系来表示。  
&emsp;&emsp;此时我们引入一种节点用来表示这种逻辑关系，并称其为**逃逸节点（Escape Node）**。而**逃逸节点**被连接在图内时实际上不会对栈上内容造成任何影响，只被用于表示逻辑关系，并且其栈上内容和其栈上有序性会被向下传递，我们称有这类节点为**旁路节点（Bypass）**。在单独研究某一条栈上路径时，**旁路节点**都是可以被直接忽略的。在遇到需要使用**逃逸节点**的情况时，将会产生多个**栈相关流**及**栈相关流根节点**，并且每个**逃逸节点**都会指定一个确定的**栈相关流根节点**，以此来表示多个**栈相关流**之间的逻辑关系。  
&emsp;&emsp;对于任意两条**栈相关流**，它们的栈上关系必须是相互分离的。一条**栈相关流**之中的**栈相关流节点**不应该与其它任何一条不同的**栈相关流**存在**栈上联结**。也就是说除了通过**逃逸节点**，两条**栈相关流**之间必须是不连通的，否则就不应该将他们分为两条**栈相关流**，不应该使用**逃逸节点**。  
&emsp;&emsp;对于上文中的代码段，其直观图将用图 2-6 的形式表示：
```
Bytecode 2-2:
    # iconst_0
    # iconst_m1
    # istore_1
    # istore_2

Graph 2-6:
    #SRF Root [0]    #SRF Root [1]
    +----------+     +-----------+
    | iconst_0 |     | iconst_m1 |
    +----------+     +-----------+
         |0                |0
    +------------+   +------------+
    | ESCAPE [1] |   | istore [1] |
    +------------+   +------------+
         |0
    +------------+
    | istore [2] |
    +------------+
```
&emsp;&emsp;对于拥有更加复杂逻辑的代码，使用更多的**逃逸节点**来表示其逻辑关系即可。但是，**逃逸节点**仅能被连接在**栈相关流**的边路径之中，如果此种无栈上联结的情况发生在了某一个**栈相关流**的尾部，则**逃逸节点**就不能被使用。因为此时栈上已经没有内容，更不会存在**栈上联结**，如果使用会破坏  **SRFG**  的图性质及**旁路节点**的传递性性质。  
&emsp;&emsp;例如以下的代码段 2-3：
```
Bytecode 2-3:
    # iconst_0
    # istore_1
    # iconst_m1
    # istore_2
```
&emsp;&emsp;为了解决此种例外，我们为**末节点**添加了一种可选的属性，用来表示当前**栈相关流**结束后与其它**栈相关流**的逻辑联系，称其为**末端逃逸（Terminal escape）**。而如果某一个**栈相关流**的**末节点**没有**末端逃逸**属性，则意味着这一个**栈相关流**已经到达了某组**栈相关流**的某一个逻辑末端（一个**SRFG**可以拥有多个逻辑末端，就比如一段代码中可以存在多个 ```return``` 指令）。  
&emsp;&emsp;而上文中的代码则可以用以下的图 2-7 来表示：
```
Bytecode 2-3:
    # iconst_0
    # istore_1
    # iconst_m1
    # istore_2

Graph 2-7:
    #SRF Root [0]               #SRF Root [1]
    +----------+                +-----------+
    | iconst_0 |                | iconst_m1 |
    +----------+                +-----------+
         |0                           |0
    +-----------------------+   +------------+
    | istore [1]            |   | istore [2] |
    | - - - - - - - - - - - |   +------------+
    | ATTR:                 |
    |  TERMINAL ESCAPE [1]  |
    +-----------------------+
```

### <a id = "2-5">2.5&nbsp;跳转</a>
&emsp;&emsp;虽然说运用逃逸可以表示非栈上联结逻辑，但是至此 **SRFG** 仍然无法表示逻辑跳转。逻辑跳转中可能还会包含着栈上联结关系，**SRFG** 中不允许将多个栈上联结路径连接至同一个节点，否则会使图表示的逻辑关系与代码原有的逻辑关系不同，破坏连接的有序性。并且在此情况下如果想要得到正确的逻辑含义，则会使图的遍历过程变得较为复杂，不利于代码和 **SRFG** 的维护。  
&emsp;&emsp;例如以下这段代码 2-4，至此的 **SRFG** 是无法表示的：
```
Bytecode 2-4:
    # ...
    # if_icmpeq L1
    # iconst_0
L1: # goto L2
    # iconst_1
L2: # ireturn
```
&emsp;&emsp;为了解决以上情况，我们将**栈相关流**进行分组，而我们称这样由一个或多个**栈相关流**构成的组为**块**。连接在一个**块**之前的某一个**块**称为其**上级块**，连接在一个**块**之后的一个**块**称为其**下级块**。如果当前**块**不是整个 **SRFG** 的结尾，则还会连接一个且最多一个**下级块**。在一个 **SRFG** 之中，可以有多个**上级块**指向某一个**块**，而一个**块**只能指向唯一的一个**下级块**，或不指向任何的**块**。  
&emsp;&emsp;用直观图可表示为如图 2-8 的形式：
```
Graph 2-8:
    +—B0—————————————————————————————————————————————————+
    |  #SRF Root [0]    #SRF Root [1]   #SRF Root [...]  |
    |  +--------+       +--------+      +---------+      |
    |  | Node 1 |       | Node n |      |   ...   |      |
    |  +--------+       +--------+      +---------+      |
    |      |                |                            |
    |  +---------+      +---------+                      |
    |  |   ...   |      |   ...   |                      |
    |  +---------+      +---------+        +---------+   |
    +——————————————————————————————————————| Next B1 |———+
                                           +---------+
    +—B1—————————+
    |    ....    |
    +————————————+
```
&emsp;&emsp;通常情况下，将**栈相关流**分块的依据是存在跳转关系的**标签（Label）**，也就是存在跳转指令的直接引用的**标签**，其它的标签（例如行号标签、形参信息标签、本地变量信息标签等）一般是不作为**栈相关流**的分块依据的。  
&emsp;&emsp;根据前文对于 **SRFG** 的规定，**块**与**块**之间也是不允许存在直接的栈上联结关系的节点连接的，但是**块**与**块**之间是完全有可能存在实际上的栈上联结的，就比如前文中的代码段 2-4。此时，我们引入两种新的节点，用来表示**块**之间的栈上联结关系，称其为**栈消隐节点**和**栈复位节点**。  
&emsp;&emsp;**栈消隐节点**表示当前**栈相关流**在进行跳转时的栈上内容及其跳转时栈上联结的向外延申关系，并且当某一个**栈消隐节点**不为**末节点**时具有向下传递性。任何一个**栈消隐节点**都必须存在至少一个与其连接的**上边**，即不为**首节点**。  
&emsp;&emsp;**栈复位节点**表示当前**栈相关流**的某些栈上内容来自于跳转之前的**块**。任何一个**栈复位节点**都必须存在至少一个与其连接的**下边**且没有与其连接的**上边**，即为**首节点**且不为**末节点**。  
&emsp;&emsp;则对于代码段 2-4，用直观图可表示为如图 2-9 的形式（图 2-9 中，块 B2 是块 B1 的**下级块**。同时，块 B2 也是块 B0 的**下级块**。块 B0 与块 B1 为块 B2 的**上级块**。这些关系在直观图中没有被以连接的形式直接表示）：
```
Graph 2-9:
    +—B0———————————————————————————————————————————————+
    |  #SRF Root [0]                #SRF Root [1]      |    
    |  +---------+  +---------+     +----------+       |
    |  |   ...   |  |   ...   |     | iconst_0 |       |
    |  +---------+  +---------+     +----------+       |
    |       |            |               |             |
    |  +-----------------------+    +---------------+  |
    |  | if_icmpeq [B1]        |    | STACK BLANK 0 |  |
    |  | - - - - - - - - - - - |    +---------------+  |
    |  | ATTR:                 |                       |
    |  |  TERMINAL ESCAPE [1]  |                       |
    |  +-----------------------+                       |
    |                                    +---------+   |
    +————————————————————————————————————| Next B2 |———+
                                         +---------+
    +—B1——————————————————+   +—B2——————————————————+
    |  #SRF Root [0]      |   |  #SRF Root [0]      |
    |  +----------+       |   |  +---------------+  |
    |  | iconst_1 |       |   |  | STACK RESTORE |  |
    |  +----------+       |   |  +---------------+  |
    |       |             |   |       |             |
    |  +---------------+  |   |  +---------+        |
    |  | STACK BLANK 0 |  |   |  | ireturn |        |
    |  +---------------+  |   |  +---------+        |
    |                     |   +—————————————————————+
    |        +---------+  |
    +————————| Next B2 |——+
             +---------+
```
&emsp;&emsp;在一个**块**或单个**栈相关流**中可能出现多个跳转指令，所以在一个**栈相关流**中可以存在多个**栈消隐节点**，每一个**栈消隐节点**都会有自己的标号，仅用于区分不同的**栈消隐节点**，不包含有序性意义。而对于每一个跳转指令，如果在跳转时栈是非空的，则会包含一个用于指定**栈消隐节点**的属性。以代码段 2-5 与其直观图 2-10 为例：
```
Bytecode 2-5:
    # iconst_2
    # iload_1
    # iload_2
    # ifeq L1
    # iflt L2
    # goto L3
L1: # iconst_m1
    # istore_1
    # goto L3
L2: # iconst_0
    # istore_2
L3: # iload_1
    # iload_2
    # iadd
    # iadd
    # ireturn

Graph 2-10:
    +—B0—————————————————————————————————————————————————————————————+
    |  #SRF Root [0]      #SRF Root [1]         #SRF Root[2]         |
    |  +----------+       +-----------+         +-----------+        |
    |  | iconst_2 |       | iload [1] |         | iload [2] |        |
    |  +----------+       +-----------+         +-----------+        |
    |       |0                  |0                    |0             |
    |  +------------+     +-----------------+   +-----------------+  |
    |  | ESCAPE [1] |     | ifeq B1         |   | iflt B2         |  |
    |  +------------+     | - - - - - - - - |   | - - - - - - - - |  |
    |       |0            | ATTR:           |   | ATTR:           |  |
    |  +---------------+  |  STACK BLANK 0  |   |  STACK BLANK 1  |  |
    |  | STACK BLANK 0 |  +-----------------+   +-----------------+  |
    |  +---------------+                                             |
    |       |0                                                       |
    |  +------------+                                                |
    |  | ESCAPE [2] |                                                |
    |  +------------+                                                |
    |       |0                                                       |
    |  +---------------+                                             |
    |  | STACK BLANK 1 |                                             |
    |  +---------------+                                +---------+  |
    +———————————————————————————————————————————————————| Next B3 |——+
                                                        +---------+
    
    +—B1——————————————————+  +—B2——————————————————+
    |  #SRF Root [0]      |  |  #SRF Root [0]      |
    |  +-----------+      |  |  +----------+       |
    |  | iconst_m1 |      |  |  | iconst_0 |       |
    |  +-----------+      |  |  +----------+       |
    |        |0           |  |       |0            |
    |  +------------+     |  |  +------------+     |
    |  | istore [1] |     |  |  | istore [2] |     |
    |  +------------+     |  |  +------------+     |
    |                     |  |                     |
    |        +---------+  |  |        +---------+  |
    +————————| Next B3 |——+  +————————| Next B3 |——+
             +---------+              +---------+

    +—B3—————————————————————————————————+
    |  #SRF Root [0]                     |
    |  +---------------+                 |
    |  | STACK RESTORE |                 |
    |  +---------------+                 |
    |          |                         |
    |          |          +-----------+  |
    |          |          | iload [1] |  |
    |          |          +-----------+  |
    |          |0          |1            |
    |         +--------------+           |
    |         |     iadd     |           |
    |         +--------------+           |
    |          |                         |
    |          |          +-----------+  |
    |          |          | iload [2] |  |
    |          |          +-----------+  |
    |          |0          |1            |
    |         +--------------+           |
    |         |     iadd     |           |
    |         +--------------+           |
    |          |0                        |
    |   +---------+                      |
    |   | ireturn |                      |
    |   +---------+                      |
    +————————————————————————————————————+
```


## <a id = "3">3&nbsp;图算法</a>

### <a id = "3-1">3.1&nbsp;构建</a>
&emsp;&emsp;当拥有一段合法的、符合堆栈规则的字节码段时，就可以根据它来构造一个标准的 **SRFG**。在构建一个 **SRFG** 图时，还需要计算额外的一些信息，比如实时栈帧上内容以及某些本地变量，由于在本 3.1 节中，还未涉及对 **SRFG** 的更改，所以暂时不在本节的直观图中标示本地变量信息及其它信息。  

#### <a id = "3-1-1">3.1.1&nbsp;构建简单代码的&nbsp;SRFG</a>
&emsp;&emsp;以代码段 3-1 为例：
```
Bytecode 3-1:
    boolean foo()
    # iconst_0
    # ireturn
```
&emsp;&emsp;遍历一段代码的顺序总是严格自上向下的，而在一个**块**中，第一个遇到的指令总会被作为第一个**栈相关流根节点**，而其余的过程只要符合前文**图结构**章节中的定义即可。对于代码段 3-1，其构建 **SRFG** 的流程如下（图中指令之前的数字仅用于对指令进行编号，以此来对不同的指令节点进行区分，并不表示指令的实际 PC 偏移量 ）：
```
[STEP 1]

Bytecode 3-1:
    boolean foo()
    #1 iconst_0              <= Current bytecode
    #2 ireturn

Stack: 
    (1 element(s) on stack, 0 element(s) consumed)
        +———————+
        |  [0]  |
        +-------+
 BEFORE:|       |
        +———————+
 AFTER: | I: #1 |
        +———————+

Graph:
    +—B0————————————————+
    |  #SRF Root [0]    |
    |  +-------------+  |
    |  | #1 iconst_0 |  |
    |  +-------------+  |
    +———————————————————+
```
&emsp;&emsp;第一步中，首先遍历到了 ```#1 iconst_0``` 指令，此时块 B0 中还有任何的节点，所以将其作为块 B0 的第一个**栈相关流根节点**。该指令没有栈上操作数，同时会产生一个栈上元素。在栈上元素信息表中，记录了当前栈上的元素个数、每个元素的数据类型以及来源指令。（实际操作过程中不需要在每个指令节点处同时记录指令执行前和指令执行后的元素信息，在直观图中的表示是为了使过程更加清晰）  
```
[STEP 2]

Bytecode 3-1:
    boolean foo()
    # iconst_0              
    # ireturn               <= Current bytecode

Stack:
    (0 elements(s) on stack, 1 element(s) consumed)
        +———————+
        |  [0]  |
        +———————+
 BEFORE:| I: #1 |
        +———————+
 AFTER: |       |
        +-------+

Graph:
    +—B0—————————————————+
    |  #SRF Root [0]     |
    |  +-------------+   |
    |  | #1 iconst_0 |   |
    |  +-------------+   |
    |         |0         |
    |  +------------+    |
    |  | #2 ireturn |    |
    |  +------------+    |
    +————————————————————+
```
&emsp;&emsp;第二步中，遍历到了 ```#2 ireturn``` 指令，该指令有一个栈上操作数，而当前栈信息表中存在一个栈元素，并且该元素来自于 ```#1 iconst_0``` 。所以此时就将 ```#2 ireturn``` 指令直接连接在 ```#1 iconst_0``` 之后，并且栈上来自 ```#1 iconst_0``` 的元素就是 ```#2 ireturn``` 指令的第一操作数。此时，代码段 3-1 已经遍历完毕，整个控制流已经结束。在本节中暂不讨论对于 **SRFG** 的后期修改，所以块 B0 不再存在**下级块**。至此，整个关于代码段 3-1 的 **SRFG** 就已经构建完毕了。以上步骤同样可以推广到更复杂的代码的 **SRFG** 的构建。更多样例详见 examples 目录。

#### <a id = "3-1-2">3.1.2&nbsp;构建存在非栈上联结逻辑的代码的&nbsp;SRFG</a>
&emsp;&emsp;在构建 **SRFG** 时，必须确认是否的确存在严格的非栈上联结逻辑，两个**栈相关流根节点**下的**栈相关流**是不允许存在直接连接的，否则**栈相关流根节点**就失去了它的意义。在这种情况下，只应该生成一个**栈相关流根节点**与一条**栈相关流**。  
&emsp;&emsp;以代码段 3-2 为例，如果生成了如图 3-1 的 **SRFG**，则这个 **SRFG** 是非法的。
```
Bytecode 3-2:
    # iconst_0
    # iconst_1
    # invokestatic (II)V

Graph 3-1:
    #SRF Root [0]   #SRF Root [1]
    +----------+    +----------+
    | iconst_0 |    | iconst_1 |
    +----------+    +----------+
         |0              |1
       +--------------------+
       | invokestatic (II)V |
       +--------------------+
```
&emsp;&emsp;所以在生成 **SRFG** 时，我们必须关心 **SRFG** 的各个部分的连通性，以此来判断是否真正存在非栈上联结逻辑。我们可以在栈上信息中记录各个节点的来源**栈相关流**，并且生成待定的**栈相关流**，存在连通时就将其合并（也可以使用其它方法来检查连通性）。  
&emsp;&emsp;以代码段 3-3 为例，构建存在非栈上联结逻辑的代码的 **SRFG** 的过程如下:
```
[STEP 1]

Bytecode 3-3:
    int foo(int, int)
    #1 iconst_0             <= Current bytecode
    #2 iload_1
    #3 iload_2
    #4 iadd
    #5 putstatic
    #6 ireturn

Graph:
    +—B0————————————————+
    |  #SRF Root [0]    |
    |  +-------------+  |
    |  | #1 iconst_0 |  |
    |  +-------------+  |
    +———————————————————+

Stack:
    (1 element(s) on stack, 0 element(s) consumed)
        +———————+
        |  [0]  |
        +-------+
 BEFORE:|       |
        |       |
        +———————+
 AFTER: | I: #1 |
        | SRF 0 |
        +———————+
```
&emsp;&emsp;第一步中，将 ```#1 iconst_0``` 连接入 **SRFG**，并作为第一个**栈相关流根节点**。
```
[STEP 2]

Bytecode 3-3:
    int foo(int, int)
    #1 iconst_0
    #2 iload_1              <= Current bytecode
    #3 iload_2
    #4 iadd
    #5 putstatic
    #6 ireturn

Graph:
    +—B0——————————————————————————————————+
    |  #SRF Root [0]    #Unsettled [1]    |
    |  +-------------+  +--------------+  |
    |  | #1 iconst_0 |  | #2 iload [1] |  |
    |  +-------------+  +--------------+  |
    +—————————————————————————————————————+

Stack:
    (2 element(s) on stack, 0 element(s) consumed)
        +———————+———————+
        |  [0]  |  [1]  |
        +———————+-------+
 BEFORE:| I: #1 |       |
        | SRF 0 |       |
        +———————+———————+
 AFTER: | I: #1 | I: #2 |
        | SRF 0 | SRF 1 |
        +———————+———————+
```
&emsp;&emsp;第二步中，将 ```#2 iload_1``` 连接入 **SRFG**，并作为一个待定的**栈相关流根节点**。
```
[STEP 3]

Bytecode 3-3:
    int foo(int, int)
    #1 iconst_0
    #2 iload_1
    #3 iload_2              <= Current bytecode
    #4 iadd
    #5 putstatic
    #6 ireturn

Graph:
    +—B0————————————————————————————————————————————————————+
    |  #SRF Root [0]    #Unsettled [1]    #Unsettled [2]    |
    |  +-------------+  +--------------+  +--------------+  |
    |  | #1 iconst_0 |  | #2 iload [1] |  | #3 iload [2] |  |
    |  +-------------+  +--------------+  +--------------+  |
    +———————————————————————————————————————————————————————+

Stack:
    (3 element(s) on stack, 0 element(s) consumed)
        +———————+———————+———————+
        |  [0]  |  [1]  |  [2]  |
        +———————+———————+-------+
 BEFORE:| I: #1 | I: #2 |       |
        | SRF 0 | SRF 1 |       |
        +———————+———————+———————+
 AFTER: | I: #1 | I: #2 | I: #3 |
        | SRF 0 | SRF 1 | SRF 2 |
        +———————+———————+———————+
```
&emsp;&emsp;第三步中，将 ```#3 iload_2``` 连接入 **SRFG**，并作为一个待定的**栈相关流根节点**。
```
[STEP 4]

Bytecode 3-3:
    int foo(int, int)
    #1 iconst_0
    #2 iload_1
    #3 iload_2
    #4 iadd                 <= Current bytecode
    #5 putstatic
    #6 ireturn

Graph:
    +—B0———————————————————————————————————————————————————+
    |  #SRF Root [0]    #Unsettled [1]                     |
    |  +-------------+  +--------------+                   |
    |  | #1 iconst_0 |  | #2 iload [1] |                   |
    |  +-------------+  +--------------+                   |
    |                          |                           |
    |                          |         +--------------+  |
    |                          |         | #3 iload [2] |  |
    |                          |         +--------------+  |
    |                          |0               |1         |
    |                         +------------------+         |
    |                         |     #4 iadd      |         |
    |                         +------------------+         |
    +——————————————————————————————————————————————————————+


Stack:
    (2 element(s) on stack, 2 element(s) consumed)
        +———————+———————+———————+
        |  [0]  |  [1]  |  [2]  |
        +———————+———————+———————+
 BEFORE:| I: #1 | I: #2 | I: #3 |
        | SRF 0 | SRF 1 | SRF 2 |
        +———————+———————+-------+
 AFTER: | I: #1 | I: #4 |       |
        | SRF 0 | SRF 1 |       |
        +———————+———————+-------+
```
&emsp;&emsp;第四步中，```#4 iadd``` 拥有两个操作数，连接入图时就将栈顶两个元素所指向的节点按顺序作为其**上节点**。而在 ```#4 iadd``` 连接入图时，它的两个操作数来自于不同的**栈相关流**，即**待定栈相关流** ```SRF 1``` 就与**待定栈相关流** ```SRF 2``` 存在连通性。此时，我们就需要将**栈相关流** ```SRF 1``` 与**栈相关流** ```SRF 2``` 合并。为了方便操作，此处我们对它们进行**向前合并**，也就是将**待定栈相关流** ```SRF 2``` 合并入**栈相关流** ```SRF 1``` 中。此时 ```#3 LOAD [2]``` 就降级为普通的指令节点，而不再是**待定栈相关流根节点**，并且**待定栈相关流** ```SRF 2``` 在这一步中也将不复存在。
```
[STEP 5]

Bytecode 3-3:
    int foo(int, int)
    #1 iconst_0
    #2 iload_1
    #3 iload_2
    #4 iadd
    #5 putstatic            <= Current bytecode
    #6 ireturn

Graph:
    +—B0———————————————————————————————————————————————————+
    |  #SRF Root [0]    #SRF Root [1]                      |
    |  +-------------+  +--------------+                   |
    |  | #1 iconst_0 |  | #2 iload [1] |                   |
    |  +-------------+  +--------------+                   |
    |         |0               |                           |
    |  +------------+          |         +--------------+  |
    |  | ESCAPE [1] |          |         | #3 iload [2] |  |
    |  +------------+          |         +--------------+  |
    |                          |0               |1         |
    |                         +------------------+         |
    |                         |     #4 iadd      |         |
    |                         +------------------+         |
    |                                  |0                  |
    |                         +------------------+         |
    |                         |   #5 putstatic   |         |
    |                         +------------------+         |
    +——————————————————————————————————————————————————————+

Stack:
    (1 element(s) on stack, 1 element(s) consumed)
        +———————+———————+
        |  [0]  |  [1]  |
        +———————+———————+
 BEFORE:| I: #1 | I: #2 |
        | SRF 0 | SRF 1 |
        +———————+-------+
 AFTER: | I: #1 |       |
        | SRF 0 |       |
        +———————+-------+
```
&emsp;&emsp;第五步中，```#5 putstatic``` 拥有一个操作数，连接入图时就将栈顶一个元素所指向的节点作为它的**上节点**。而在 ```#5 putstatic``` 连接入图时，栈内已经没有来自**栈相关流** ```SRF 1``` 的元素了，此时也就确定了**待定栈相关流** ```SRF 1``` 和其他的**栈相关流**没有连通性。所以**待定栈相关流** ```SRF 1``` 就可以不再有**待定**的标签，而被正式作为一条**栈相关流**，并且在所有的剩余的栈内元素后连接一个**逃逸节点**（**逃逸节点**的连接可能会引发**栈相关流**之间的合并，此时只需按照前文中**栈相关流**的连通性检查及合并规则进行操作即可。且发生合并时相关的**栈相关流**除了第 0 号**栈相关流**都应是待定**栈相关流**，因为发生合并的前提是栈上还存在与某个**栈相关流**有关的元素）。
```
[STEP 6]

Bytecode 3-3:
    int foo(int, int)
    #1 iconst_0
    #2 iload_1
    #3 iload_2
    #4 iadd
    #5 putstatic
    #6 ireturn              <= Current bytecode

Graph:
    +—B0———————————————————————————————————————————————————+
    |  #SRF Root [0]    #SRF Root [1]                      |
    |  +-------------+  +--------------+                   |
    |  | #1 iconst_0 |  | #2 iload [1] |                   |
    |  +-------------+  +--------------+                   |
    |         |0               |                           |
    |  +------------+          |         +--------------+  |
    |  | ESCAPE [1] |          |         | #3 iload [2] |  |
    |  +------------+          |         +--------------+  |
    |         |0               |0               |1         |
    |  +------------+         +------------------+         |
    |  | #6 ireturn |         |     #4 iadd      |         |
    |  +------------+         +------------------+         |
    |                                  |0                  |
    |                         +------------------+         |
    |                         |   #5 putstatic   |         |
    |                         +------------------+         |
    +——————————————————————————————————————————————————————+

Stack:
    (0 element(s) on stack, 1 element(s) consumed)
        +———————+
        |  [0]  |
        +———————+
 BEFORE:| I: #1 |
        | SRF 0 |
        +-------+
 AFTER: |       |
        |       |
        +-------+
```
&emsp;&emsp;第六步中， ```#6 ireturn``` 拥有一个操作数，连接入图时就将栈顶一个元素所指向的节点作为它的**上节点**。此时已经遍历完代码段中的所有指令，代码段 3-3 的**SRFG**也就构建完毕了。以上步骤同样可以推广到更复杂的代码的 **SRFG** 的构建。更多样例详见 examples 目录。

### <a id = "3-1-3">3.1.3&nbsp;构建存在跳转的代码的&nbsp;SRFG</a>
&emsp;&emsp;**块**的存在意义即是处理代码段中的跳转逻辑，所以**块**的构建就与跳转指令及其跳转目标标签相关。对于代码段 3-4，其 **SRFG** 构建过程如下：
```
[STEP 1]

Bytecode 3-4:
    static boolean isNegative(int)
    #1 iload_0              <= Current bytecode
L1: #2 iflt L2
    #3 iconst_0
    #4 goto L3
L2: #5 iconst_1
L3: #6 ireturn

Bytecode 3-4 Attributes:
    L1: Line number 5
    L3: Line number 6

Graph:
    +—B0—————————————————+
    |  #SRF Root [0]     |
    |  +--------------+  |
    |  | #1 iload [0] |  |
    |  +--------------+  |
    +————————————————————+

Stack:
    (1 element(s) on stack, 0 element(s) consumed)
        +———————+
        |  [0]  |
        +-------+
 BEFORE:|       |
        |       |
        +———————+
 AFTER: | I: #1 |
        | SRF 0 |
        +———————+
```
&emsp;&emsp;第一步中，将 ```#1 iload_0``` 连接入图。
```
[STEP 2]

Bytecode 3-4:
    static boolean isNegative(int)
    #1 iload_0
L1: #2 iflt L2              <= Current bytecode
    #3 iconst_0
    #4 goto L3
L2: #5 iconst_1
L3: #6 ireturn

Bytecode 3-4 Attributes:
    L1: Line number 5
    L3: Line number 6

Graph:
    +—B0—————————————————+  +—B1——————+
    |  #SRF Root [0]     |  |         |
    |  +--------------+  |  +—————————+
    |  | #1 iload [0] |  |
    |  +--------------+  |
    |         |0         |
    |  +------------+    |
    |  | #2 iflt B1 |    |
    |  +------------+    |
    +————————————————————+

Label-Block map:
    L2 -> B1

Stack (B0):
    (0 element(s) on stack, 1 element(s) consumed)
        +———————+
        |  [0]  |
        +———————+
 BEFORE:| I: #1 |
        | SRF 0 |
        +-------+
 AFTER: |       |
        |       |
        +-------+
```
&emsp;&emsp;第二步中，```#2 iflt L2``` 拥有一个操作数，且以 ```L2``` 作为它的目标跳转标签，连接入图时就将栈顶一个元素所指向的节点作为它的**上节点**。对于标签 ```L2```，构造一个**块** ```B1``` ，但其中还没有任何节点，因为还未实际遍历到标签 ```L2``` 处。对于标签 ```L1```，没有跳转指令指向这个标签，所以不需要构造一个新的**块**。
```
[STEP 3]

Bytecode 3-4:
    static boolean isNegative(int)
    #1 iload_0
L1: #2 iflt L2
    #3 iconst_0             <= Current bytecode
    #4 goto L3
L2: #5 iconst_1
L3: #6 ireturn

Bytecode 3-4 Attributes:
    L1: Line number 5
    L3: Line number 6

Graph:
    Graph:
    +—B0———————————————————————————————————————————+  +—B1——————+
    |  #SRF Root [0]              #SRF Root [1]    |  |         |
    |  +--------------+           +-------------+  |  +—————————+
    |  | #1 iload [0] |           | #3 iconst_0 |  |
    |  +--------------+           +-------------+  |
    |         |0                                   |
    |  +-----------------------+                   |
    |  | #2 iflt B1            |                   |
    |  + - - - - - - - - - - - +                   |
    |  | ATTR:                 |                   |
    |  |  TERMINAL ESCAPE [1]  |                   |
    |  +-----------------------+                   |
    +——————————————————————————————————————————————+

Label-Block map:
    L2 -> B1

Stack (B0):
    (1 element(s) on stack, 0 element(s) consumed)
        +———————+
        |  [0]  |
        +-------+
 BEFORE:|       |
        |       |
        +———————+
 AFTER: | I: #3 |
        | SRF 1 |
        +———————+
```
&emsp;&emsp;第三步中，在访问 ```#3 iconst_0``` 之前栈上内容就已经为空，所以可直接判断**栈相关流** ```SRF 0``` 已经到达末尾，将 ```#3 iconst_0``` 直接作为新的**栈相关流根节点**，生成新**栈相关流** ```SRF 1```，并且为 ```#2 iflt B1``` 添加**尾部逃逸**的属性。
```
[STEP 4]

Bytecode 3-4:
    static boolean isNegative(int)
    #1 iload_0
L1: #2 iflt L2
    #3 iconst_0
    #4 goto L3              <= Current bytecode
L2: #5 iconst_1
L3: #6 ireturn

Bytecode 3-4 Attributes:
    L1: Line number 5
    L3: Line number 6

Graph:
    +—B0—————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]      |
    |  +--------------+           +-------------+    |
    |  | #1 iload [0] |           | #3 iconst_0 |    |
    |  +--------------+           +-------------+    |
    |         |0                         |0          |
    |  +-----------------------+  +---------------+  |
    |  | #2 iflt B1            |  | STACK BLANK 0 |  |          
    |  + - - - - - - - - - - - +  +---------------+  |
    |  | ATTR:                 |                     |
    |  |  TERMINAL ESCAPE [1]  |                     |
    |  +-----------------------+        +---------+  |
    +———————————————————————————————————| Next B2 |——+
                                        +---------+

    +—B1——————+  +—B2——————+
    |         |  |         |
    +—————————+  +—————————+

Label-Block map:
    L2 -> B1
    L3 -> B2

Stack (B0):
    (0 element(s) on stack, 1 element(s) consumed)
        +———————+
        |  [0]  |
        +———————+
 BEFORE:| I: #3 |
        | SRF 1 |
        +-------+
 AFTER: |       |
        |       |
        +-------+

Blanked stack:
    For B0 -> B2 (1 stack element(s)):
        +—————+
        | [0] |
        +—————+
        |  I  |
        +—————+
```
&emsp;&emsp;第四步中，```#4 goto L3``` 指令表示当前的**块** ``B0`` 已经到达了逻辑尾部，但此时栈是非空的，故将一个**栈消隐节点**连接到所有的剩余栈上内容之后。并且对于标签 ```L3``` 构造一个新的空**块** ```B2```，再将**块** ```B2``` 作为**块** ```B0``` 的下级块。  
&emsp;&emsp;需要注意的是，通常情况下，在一个**块**中，作为**尾节点**的一个**栈消隐节点**表示这个**块**已经到达了逻辑尾部，并且下一条指令常常会有被某一条跳转指令所指向的标签。如果接下来的指令没有这样的标签，则也可以在本**块**中独立生成一条新的**栈相关流**，并在此**栈消隐节点**上添加**尾部逃逸**的属性。但是这条**栈相关流**表示的通常是一段**死代码（Dead code）**，因为在达到这条**栈相关流**的相关代码之前就已经跳转到了其他的**块**，这条**栈相关流**在逻辑上是不可达的（暂不考虑对 **SRFG** 的后期修改）。
```
[STEP 5]

Bytecode 3-4:
    static boolean isNegative(int)
    #1 iload_0
L1: #2 iflt L2
    #3 iconst_0
    #4 goto L3
L2: #5 iconst_1             <= Current bytecode
L3: #6 ireturn

Bytecode 3-4 Attributes:
    L1: Line number 5
    L3: Line number 6

Graph:
    +—B0—————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]      |
    |  +--------------+           +-------------+    |
    |  | #1 iload [0] |           | #3 iconst_0 |    |
    |  +--------------+           +-------------+    |
    |         |0                         |0          |
    |  +-----------------------+  +---------------+  |
    |  | #2 iflt B1            |  | STACK BLANK 0 |  |          
    |  + - - - - - - - - - - - +  +---------------+  |
    |  | ATTR:                 |                     |
    |  |  TERMINAL ESCAPE [1]  |                     |
    |  +-----------------------+        +---------+  |
    +———————————————————————————————————| Next B2 |——+
                                        +---------+

    +—B1———————————————+  +—B2——————+
    |  #SRF Root [0]   |  |         |
    |  +-------------+ |  +—————————+
    |  | #5 iconst_1 | |
    |  +-------------+ |
    +——————————————————+  

Label-Block map:
    L2 -> B1
    L3 -> B2

Stack (B1):
    (1 element(s) on stack, 0 element(s) consumed)
        +———————+
        |  [0]  |
        +-------+
 BEFORE:|       |
        |       |
        +———————+
 AFTER: | I: #5 |
        | SRF 0 |
        +———————+

Blanked stack:
    For B0 -> B2 (1 stack element(s)):
        +—————+
        | [0] |
        +—————+
        |  I  |
        +—————+
```
&emsp;&emsp;第五步中，```#5 iconst_1``` 指令上有一个标签 ```L2```，而标签 ```L2``` 与**块** ```B1``` 相关联，表示此时已经进入了**块** ```B1``` 的代码段，所以将 ```#5 iconst_1``` 直接连接入**块** ```B1``` 中。
```
[STEP 6]

Bytecode 3-4:
    static boolean isNegative(int)
    #1 iload_0
L1: #2 iflt L2
    #3 iconst_0
    #4 goto L3
L2: #5 iconst_1
L3: #6 ireturn              <= Current bytecode

Bytecode 3-4 Attributes:
    L1: Line number 5
    L3: Line number 6

Graph:
    +—B0—————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]      |
    |  +--------------+           +-------------+    |
    |  | #1 iload [0] |           | #3 iconst_0 |    |
    |  +--------------+           +-------------+    |
    |         |0                         |0          |
    |  +-----------------------+  +---------------+  |
    |  | #2 iflt B1            |  | STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +---------------+  |
    |  | ATTR:                 |                     |
    |  |  TERMINAL ESCAPE [1]  |                     |
    |  +-----------------------+        +---------+  |
    +———————————————————————————————————| Next B2 |——+
                                        +---------+

    +—B1——————————————————+  +—B2——————————————————+
    |  #SRF Root [0]      |  |  #SRF Root [0]      |
    |  +-------------+    |  |  +---------------+  |
    |  | #5 iconst_1 |    |  |  | STACK RESTORE |  |
    |  +-------------+    |  |  +---------------+  |
    |         |0          |  |         |0          |
    |  +---------------+  |  |  +------------+     |
    |  | STACK BLANK 0 |  |  |  | #6 ireturn |     |
    |  +---------------+  |  |  +------------+     |
    |                     |  +—————————————————————+
    |        +---------+  |
    +————————| Next B2 |——+
             +---------+  

Label-Block map:
    L2 -> B1
    L3 -> B2

Stack (B1):
    (0 element(s) on stack, 1 element(s) consumed)
        +———————+
        |  [0]  |
        +———————+
 BEFORE:| I: #5 |
        | SRF 0 |
        +-------+
 AFTER: |       |
        |       |
        +-------+

Stack (B2):
    Empty

Blanked stack:
    For B0 -> B2 (1 stack element(s)):
        +—————+
        | [0] |
        +—————+
        |  I  |
        +—————+

    For B1 -> B2 (1 stack element(s))
        +—————+
        | [0] |
        +—————+
        |  I  |
        +—————+
```
&emsp;&emsp;在第六步中，遍历到了指令 ```#6 ireturn``` 及其标签 ```L3```，所以要先将**栈相关流**的构建环境从当前的**块** ```B1``` 切换到标签 ```L3``` 所相关联的**块**，即**块** ```B2```。在逻辑上，**块** ```B1``` 到**块** ```B2``` 的过渡是直接的，没有通过任何的跳转指令，所以直接将**块** ```B2``` 作为**块** ```B1``` 的**下级块**。此时**块** ```B1``` 中仍然存在栈上元素，而**块** ```B1``` 已经到达了它的逻辑尾部，且不是整个 **SRFG** 的逻辑尾部，所以在**块** ```B1``` 的剩余栈上元素之后再连接一个**栈消隐节点**（对于此时**栈相关流**的生成与合并详见前文内容）。  
&emsp;&emsp;在完成了**块** ```B1``` 中的处理之后，就可以将构建环境切换到**块** ```B2``` 之中了。指令 ```#6 ireturn``` 拥有一个操作数，但此时**块** ```B2``` 的栈是空的，故不能将 ```#6 ireturn``` 直接连接入**块** ```B2``` 之中。此时我们就需要先将一个**栈复位节点**连接入**块** ```B2``` 之中，并且在构造此**栈复位节点**的时候，我们需要遍历所有**块** ```B1``` 的**上级块**的栈消隐信息来保证所需的栈上元素的一致性。在完成当前**栈复位节点**的构造与验证之后，再将 ```#6 ireturn``` 指令直接连接在当前**栈复位节点**之后即可。  
&emsp;&emsp;此时，关于代码段 3-4 的 **SRFG** 也就全部构建完成了。以上步骤同样可以推广到更复杂的代码的 **SRFG** 的构建。更多样例详见 examples 目录。


### <a id = "3-2">3.2&nbsp;遍历与还原</a>
&emsp;&emsp;对于 **SRFG** 的遍历的过程就可近似看作从 **SRFG** 还原成字节码的过程。对于一个 **SRFG**，遍历的起点总是**块** ```B0```，而之后的遍历顺序却不一定是按照 ```B1``` -> ```B2``` -> ```B3``` -> ```...``` 的顺序的。**块** ```B0``` 是整个 **SRFG** 的**根块**，而**块**的名称中的编号仅仅是用于在直观图中区分、标明各个不同的块的，与遍历的顺序无关，具体的遍历顺序与**块**中的各个**栈相关流**的内容有关。  
&emsp;&emsp;在遍历的过程中，每个节点只能被访问一次，同时每一条指令只会被还原一次（具体的保证机制由不同的实现决定）。而对于存在**上节点**的节点来说，必须在它所有的与其直接连接的**上节点**都被访问过之后才可以再进行访问。

#### <a id = "3-2-1">3.2.1&nbsp;简单&nbsp;SRFG&nbsp;的遍历与还原</a>
&emsp;&emsp;以图 3-2 所表示的 **SRFG** 为例，其遍历过程如下：
```
[STEP 1]

Graph 3-2:
    +—B0————————————————+
    |  #SRF Root [0]    |
    |  +-------------+  |
    |  | #1 iconst_0 |  |
    |  +-------------+  |
    |         |0        |
    |  +------------+   |
    |  | #2 ireturn |   |
    |  +------------+   |
    +———————————————————+

Current:
    +-------------+
    | #1 iconst_0 |
    +-------------+
           |
          ...

Visited:
    #1

Bytecode queue:
    #1 iconst_0
```
&emsp;&emsp;第一步中，遍历到了 ```#1 iconst_0``` 节点，它没有任何的**上节点**，此时将 ```iconst_0``` 指令加入到被还原的字节码队列中。
```
[STEP 2]

Graph 3-2:
    +—B0————————————————+
    |  #SRF Root [0]    |
    |  +-------------+  |
    |  | #1 iconst_0 |  |
    |  +-------------+  |
    |         |0        |
    |  +------------+   |
    |  | #2 ireturn |   |
    |  +------------+   |
    +———————————————————+

Current:
         ...
          |0
    +------------+
    | #2 ireturn |
    +------------+

Visited:
    #1, #2

Bytecode queue:
    #1 iconst_0
    #2 ireturn
```
&emsp;&emsp;第二步中，遍历到了 ```#2 ireturn``` 节点，而它有一个**上节点**，此时必须保证其所有**上节点**都被访问过，因为这些节点及其表示的指令在逻辑上都必须发生在 ```#2 ireturn``` 之前。这时我们就需要遍历它的所有**上节点**来检查是否都被访问过，这一个过程被称为**前向担保（Forward Assurance）**。若该节点的**上节点**，仍然存在未被访问的**上节点**，则对该节点的**上节点**进行**前向担保**。也就是说，访问到任意存在未被访问的**上节点**的节点，都需要对其进行**前向担保**。  
&emsp;&emsp;在完成对于 ```#2 ireturn``` 所有的**上节点**的遍历检查之后，发现其所有的**上节点**，即 ```#1 iconst_0``` ，都已经被访问过了。也就是说，对于 ```#2 ireturn``` 这一指令节点，不需要进入**前向担保**的过程，所以直接将 ```ireturn``` 指令加入到被还原的字节码队列中。  
&emsp;&emsp;又由于 ```#2 ireturn``` 指令节点没有任何的**下节点**，并且该指令节点没有包含**尾部逃逸**的属性，此时对于**块** ```B0``` 的遍历过程就已经全部结束，而**块** ```B0``` 又不存在其**下级块**，所以对于图 3-2 所表示的 **SRFG** 的遍历与还原的过程就已经全部结束了。  
&emsp;&emsp;若一个指令节点有多个**上节点**，也要保证其所有的**上节点**都已经被访问过。以图 3-3 所表示的 **SRFG** 为例，其遍历过程如下：
```
[STEP 1]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
    +-------------+
    | #1 iconst_0 |
    +-------------+
           |
          ...

Visited:
    #1

Bytecode queue:
    #1 iconst_0

Transaction table:
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;此时引入**事务表（Transaction table）**，被用于确定**块**的访问事务或辅助检查 **SRFG** 的合法性，其为一个双向链表，且常用到其可作为栈的性质（此处的**事务表**是用于方便表现 **SRFG** 图的不同遍历状态，也可将其作为具体实现，但它不是 **SRFG** 的标准的一部分。使用其他的方法来保证相同的遍历流程亦可）。其对于**块**访问的具体作用将会在第 [3.1.3](#3-1-3) 节中体现，并将一个对**块** ```B0``` 的块访问事务推入事务表。  
&emsp;&emsp;第一步中，遍历到了 ```#1 iconst_0``` 节点，将其直接加入至被还原的字节码队列中，并将其标记为**已访问（Visited）**。
```
[STEP 2]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
       ...           ...
        |             |
    +----------------------+
    | #5 invokestatic(I[)I |
    +----------------------+
        |
       ...

Visited:
    #1

Bytecode queue:
    #1 iconst_0

Transaction table:
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第二步中，遍历到了 ```#5 invokestatic(I[)I``` 节点，该节点拥有两个**上节点**，并且存在未被访问过的**上节点**，所以进入 ```#5``` 节点的**前向担保**过程，并将一个关于 ```#5``` 节点的**前向担保**事务推入事务表顶端。
```
[STEP 3]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
       ...
        |             
    +------------+
    |   #4 dup   |
    +------------+
        |     |
       ...   ...

Visited:
    #1

Bytecode queue:
    #1 iconst_0

Transaction table:
    #  FORWARD ASSURANCE (#4)
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第三步中，由于 ```#5``` 节点的**前向担保**过程，向上遍历到了 ```#4 dup``` 节点，而此时 ```#4``` 也存在未被访问的**上节点**，所以进入 ```#4``` 节点的**前向担保**过程，并将一个关于 ```#4``` 节点的**前向担保**事务推入事务表顶端。
```
[STEP 4]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
          ...
           |
    +--------------+
    | #3 anewarray |
    +--------------+
           |
          ...

Visited:
    #1

Bytecode queue:
    #1 iconst_0

Transaction table:
    #  FORWARD ASSURANCE (#3)
    #  FORWARD ASSURANCE (#4)
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第四步中，由于 ```#4``` 节点的**前向担保**过程，向上遍历到了 ```#3 anewarray``` 节点，而此时 ```#3``` 也存在未被访问的**上节点**，所以进入 ```#3``` 节点的**前向担保**过程，并将一个关于 ```#3``` 节点的**前向担保**事务推入事务表顶端。
```
[STEP 5]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
    +-------------+
    | #2 iconst_1 |
    +-------------+
           |
          ...

Visited:
    #1, #2

Bytecode queue:
    #1 iconst_0
    #2 iconst_1

Transaction table:
    #  FORWARD ASSURANCE (#3)
    #  FORWARD ASSURANCE (#4)
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第五步中，由于 ```#3``` 节点的**前向担保**过程，向上遍历到了 ```#2 iconst_1``` 节点。此时，```#3``` 节点不存在任何的未被访问**上节点**，所以将其直接加入至被还原的字节码队列中，并将其标记为已访问。
```
[STEP 6]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
          ...
           |
    +--------------+
    | #3 anewarray |
    +--------------+
           |
          ...

Visited:
    #1, #2, #3
    
Bytecode queue:
    #1 iconst_0
    #2 iconst_1
    #3 anewarray

Transaction table:
    #  FORWARD ASSURANCE (#4)
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第六步中，由于对 ```#2``` 节点的访问已经完成，所以按从上到下的顺序回到 ```#3 anewarray``` 节点。此时 ```#3``` 节点的所有的**上节点**都已经被访问过了，所以 ```#3``` 节点的**前向担保**过程结束，将其直接添加入被还原的字节码队列中，并且标记为已访问，再将事务表中关于 ```#3``` 节点的**前向担保**事务移除（在完成**前向担保**过程后移除此类事务时，其必须在事务表的顶端，否则就意味着 **SRFG** 是非法的或遍历的过程存在问题）。
```
[STEP 7]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
       ...
        |             
    +------------+
    |   #4 dup   |
    +------------+
        |     |
       ...   ...

Visited:
    #1, #2, #3, #4

Bytecode queue:
    #1 iconst_0
    #2 iconst_1
    #3 anewarray
    #4 dup

Transaction table:
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第七步中，由于对 ```#3``` 节点的访问已经完成，所以按从上到下的顺序回到 ```#4 dup``` 节点。此时 ```#4``` 节点的所有的**上节点**都已经被访问过了，所以 ```#4``` 节点的**前向担保**过程结束，将其直接添加入被还原的字节码队列中，并且标记为已访问，再将事务栈中关于 ```#4``` 节点的**前向担保**事务移除。
```
[STEP 8]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
     ...  ...  ...
      |    |    |
    +--------------+
    |  #7 aastore  |
    +--------------+

Visited:
    #1, #2, #3, #4

Bytecode queue:
    #1 iconst_0
    #2 iconst_1
    #3 anewarray
    #4 dup

Transaction table:
    #  FORWARD ASSURANCE (#7)
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第八步中，由于对 ```#4``` 节点的访问已经完成，所以应按从上到下的顺序进行遍历。而当一个节点拥有多个**下节点**时，其**下边**的连接顺序也包含了有序性的意义，由于前文中这种有序性并没有很具体地体现出来，所以没有特别提出。故根据图中的**下边**的序数，此时向下遍历到 ```#7 aastore``` 节点。而 ```#7``` 节点存在未被访问的**上节点**，故进入 ```#7``` 节点的**前向担保**过程，并将一个关于 ```#7``` 节点的**前向担保**事务推入事务表顶端。
```
[STEP 9]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
    +-------------+
    | #8 iconst_0 |
    +-------------+
           |
          ...

Visited:
    #1, #2, #3, #4, #8

Bytecode queue:
    #1 iconst_0
    #2 iconst_1
    #3 anewarray
    #4 dup
    #8 iconst_0

Transaction table:
    #  FORWARD ASSURANCE (#7)
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第九步中，由于 ```#7``` 节点的**前向担保**过程，按照 ```#7``` 节点的**上边**连接序号的顺序，遍历到 ```#8 iconst_0``` 节点。而 ```#8``` 节点不存在任何未被访问的**上节点**，所以将其直接加入被还原的字节码队列，并将其标记为已访问。
```
[STEP 10]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
    +--------------+
    | #9 getstatic |
    +--------------+
        |
       ...

Visited:
    #1, #2, #3, #4, #8, #9

Bytecode queue:
    #1 iconst_0
    #2 iconst_1
    #3 anewarray
    #4 dup
    #8 iconst_0
    #9 getstatic

Transaction table:
    #  FORWARD ASSURANCE (#7)
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第十步中，由于对 ```#8``` 节点的访问已经完成，所以按从上到下的顺序回到 ```#7 aastore``` 节点。此时，由于 ```#7``` 节点还存在未被访问的**上节点**，所以其**前向担保**过程尚未结束，继续按其**上边**连接序号的顺序进行**前向担保**，遍历到 ```#9 getstatic```。```#9``` 节点不存在任何未被访问的**上节点**，所以直接将其加入到被还原的字节码队列，并将其标记为已访问。
```
[STEP 11]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
     ...  ...  ...
      |    |    |
    +--------------+
    |  #7 aastore  |
    +--------------+


Visited:
    #1, #2, #3, #4, #8, #9, #7

Bytecode queue:
    #1 iconst_0
    #2 iconst_1
    #3 anewarray
    #4 dup
    #8 iconst_0
    #9 getstatic
    #7 aastore

Transaction table:
    #  FORWARD ASSURANCE (#5)
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第十一步中，由于对 ```#9``` 节点的访问已经完成，所以按从上到下的顺序回到 ```#7 aastore``` 节点。此时，```#7``` 节点已经不存在任何未被访问的**上节点**，即 ```#7``` 节点的**向前担保**过程就结束了，故将其直接加入被还原的字节码队列，并将其标记为已访问，再将事务表中关于 ```#7``` 节点的**前向担保**事务移除。
```
[STEP 12]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
       ...           ...
        |             |
    +----------------------+
    | #5 invokestatic(I[)I |
    +----------------------+
        |
       ...

Visited:
    #1, #2, #3, #4, #8, #9, #7, #5

Bytecode queue:
    #1 iconst_0
    #2 iconst_1
    #3 anewarray
    #4 dup
    #8 iconst_0
    #9 getstatic
    #7 aastore
    #5 invokestatic(I[)I

Transacton table:
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第十二步中，对于 ```#4 dup``` 节点的序数为 0 的**下边**所连接的**下节点**已经完成访问，此时将继续按顺序访问序数为 1 的**下边**所连接的**下节点**，故向下遍历到了 ```#5 invkestatic(I[)I``` 节点。由于此时 ```#5``` 节点已经不存在任何未被访问的**上节点**，即 ```#5``` 节点的**前向担保**过程已结束，故将其直接加入到被还原的字节码队列中，并将其标记为已访问，再将事务表中关于 ```#5``` 节点的**前向担保**事务移除。
```
[STEP 13]

Graph 3-3:
    +—B0——————————————————————————————————————————————————————+
    |  #SRF Root [0]                                          |
    |  +-------------+                                        |
    |  | #1 iconst_0 |                                        |
    |  +-------------+                                        |
    |         |         +-------------+                       |
    |         |         | #2 iconst_1 |                       |
    |         |         +-------------+                       |
    |         |                |0                             |
    |         |         +--------------+    +--------------+  |
    |         |         | #3 anewarray |    | #9 getstatic |  |   
    |         |         +--------------+    +--------------+  |
    |         |                |0                         |   |
    |         |          +------------+  +-------------+  |   |
    |         |          |   #4 dup   |  | #8 iconst_0 |  |   |
    |         |          +------------+  +-------------+  |   |
    |         |            |1       |0       |            |   |
    |         |0           |1       |0       |1           |2  |
    |   +----------------------+  +------------------------+  |
    |   | #5 invokestatic(I[)I |  |      #7 aastore        |  |
    |   +----------------------+  +------------------------+  |
    |         |0                                              |
    |   +------------+                                        |
    |   | #6 ireturn |                                        |
    |   +------------+                                        |
    +—————————————————————————————————————————————————————————+

Current:
         ...
          |
    +------------+
    | #6 ireturn |
    +------------+

Visited:
    #1, #2, #3, #4, #8, #9, #7, #5, #6

Bytecode queue:
    #1 iconst_0
    #2 iconst_1
    #3 anewarray
    #4 dup
    #8 iconst_0
    #9 getstatic
    #7 aastore
    #5 invokestatic(I[)I
    #6 ireturn

Transaction table:
    EMPTY
```
&emsp;&emsp;第十三步中，由于对 ```#5``` 节点的访问已经完成，所以按从上到下的顺序遍历到 ```#6 ireturn``` 节点。而 ```#6``` 节点不存在任何未被访问的**上节点**，所以直接将其加入被还原的字节码队列中，并将其标记为已访问，再将事务表中的所有对 **块** ```B0``` 的块访问事务移除。  
&emsp;&emsp;需要注意的是，当一个 **SRFG** 完成遍历及还原时，其事务栈一定是空的，否则就意味着该 **SRFG** 是非法的或者遍历及还原的过程存在问题。  
&emsp;&emsp;至此，对于图 3-3 所表示的 **SRFG** 的遍历与还原过程就已经全部完成，该过程同样可以推广到更加复杂的 **SRFG** 中，更多样例详见 examples 目录。

#### <a id = "3-2-2">3.2.2&nbsp;包含逃逸的&nbsp;SRFG&nbsp;的遍历与还原</a>
&emsp;&emsp;当一个 **SRFG** 中存在非栈上联结逻辑时，就会出现逃逸。对于包含逃逸的 **SRFG** 的遍历与还原的过程，将以图 3-4 所表示的 **SRFG** 为例，其遍历过程如下：
```
[STEP 1]

Graph 3-4:
    #SRF Root [0]    #SRF Root [1]
    +-------------+     +--------------+
    | #1 iconst_0 |     | #4 iconst_m1 |
    +-------------+     +--------------+
           |0                  |0
    +---------------+   +---------------+
    | #2 ESCAPE [1] |   | #5 istore [1] |
    +---------------+   +---------------+
           |0
    +---------------+
    | #3 istore [2] |
    +---------------+

Current:
    +-------------+
    | #1 iconst_0 |
    +-------------+
           |
          ...

Visited:
    #1

Bytecode queue:
    #1 iconst_0
```
&emsp;&emsp;第一步中，遍历过程从 0 号**栈相关流**的**栈相关流根节点** ```#1 iconst_0``` 开始，将其直接加入被还原的字节码队列，并将其标记为已访问。
```
[STEP 2]

Graph 3-4:
    #SRF Root [0]    #SRF Root [1]
    +-------------+     +--------------+
    | #1 iconst_0 |     | #4 iconst_m1 |
    +-------------+     +--------------+
           |0                  |0
    +---------------+   +---------------+
    | #2 ESCAPE [1] |   | #5 istore [1] |
    +---------------+   +---------------+
           |0
    +---------------+
    | #3 istore [2] |
    +---------------+

Current:
           ...
            |
    +---------------+
    | #2 ESCAPE [1] |
    +---------------+
            |
           ...

Visited:
    #1, #2

Bytecode queue:
    #1 iconst_0

Transaction stack:
    #  ESCAPE [0] -> [1]
```
&emsp;&emsp;第二步中，遍历到了 ```#2 ESCAPE [1]``` 节点，该节点是一个**逃逸节点**，并且指向第 1 号**栈相关流**。将该节点标记为已访问，并且准备将遍历过程转移至第 1 号**栈相关流**。
```
[STEP 3]

Graph 3-4:
    #SRF Root [0]    #SRF Root [1]
    +-------------+     +--------------+
    | #1 iconst_0 |     | #4 iconst_m1 |
    +-------------+     +--------------+
           |0                  |0
    +---------------+   +---------------+
    | #2 ESCAPE [1] |   | #5 istore [1] |
    +---------------+   +---------------+
           |0
    +---------------+
    | #3 istore [2] |
    +---------------+

Current:
    +--------------+
    | #4 iconst_m1 |
    +--------------+
           |
          ...

Visited:
    #1, #2, #4

Bytecode queue:
    #1 iconst_0
    #4 iconst_m1

Transaction stack:
    #  ESCAPE [0] -> [1]
```
&emsp;&emsp;第三步中，由于 ```#2 ESCAPE [1]``` 节点是一个**逃逸节点**，并且指向第 1 号**栈相关流**，所以遍历的过程从第 1 号**栈相关流**的**栈相关流根节点**开始。故遍历到 ```#4 iconst_m1``` 节点，将其直接加入到被还原的字节码队列中，并将其标记为已访问。
```
[STEP 4]

Graph 3-4:
    #SRF Root [0]    #SRF Root [1]
    +-------------+     +--------------+
    | #1 iconst_0 |     | #4 iconst_m1 |
    +-------------+     +--------------+
           |0                  |0
    +---------------+   +---------------+
    | #2 ESCAPE [1] |   | #5 istore [1] |
    +---------------+   +---------------+
           |0
    +---------------+
    | #3 istore [2] |
    +---------------+

Current:
           ...
            |
    +---------------+
    | #5 istore [1] |
    +---------------+

Visited:
    #1, #2, #4, #5

Bytecode queue:
    #1 iconst_0
    #4 iconst_m1
    #5 istore 1
```
&emsp;&emsp;第四步中，遍历到了 ```#5 istore [1]``` 节点，该节点不存在任何的未被访问的**上节点**，所以直接将其加入到被还原的字节码队列中，并将其标记为已访问。此时，第 1 号**栈相关流**中的所有节点都已经被访问过了，即其遍历过程已经结束。根据**逃逸节点** ```#2``` 中的信息，将遍历过程转移回第 0 号**栈相关流**。
```
[STEP 5]

Graph 3-4:
    #SRF Root [0]    #SRF Root [1]
    +-------------+     +--------------+
    | #1 iconst_0 |     | #4 iconst_m1 |
    +-------------+     +--------------+
           |0                  |0
    +---------------+   +---------------+
    | #2 ESCAPE [1] |   | #5 istore [1] |
    +---------------+   +---------------+
           |0
    +---------------+
    | #3 istore [2] |
    +---------------+

Current:
           ...
            |
    +---------------+
    | #3 istore [2] |
    +---------------+

Visited:
    #1, #2, #4, #5, #3

Bytecode queue:
    #1 iconst_0
    #4 iconst_m1
    #5 istore 1
    #3 istore 2
```
&emsp;&emsp;第五步中，遍历过程已经转移回到第 0 号**栈相关流**，故从 ```#2 ESCAPE [1]``` 的位置继续从上到下按连接顺序进行遍历。此时遍历到 ```#3 istore [2]``` 节点，该节点不存在任何未被访问的**上节点**，故将其直接加入到被还原的字节码队列中，并将其标记为已访问。此时对于图 3-4 所表示的 **SRFG** 的遍历及还原的过程就已经全部结束了，该过程同样可以推广到更加复杂的 **SRFG** 中，更多样例详见 examples 目录。

#### <a id = "3-2-3">3.2.3&nbsp;包含跳转的&nbsp;SRFG&nbsp;的遍历及还原</a>
&emsp;&emsp;当一个 **SRFG** 中存在跳转指令时，就会存在多个**块**。对于包含跳转的 **SRFG** 的遍历及还原的过程，将以图 3-5 所表示的 **SRFG** 为例，其遍历过程如下：
```
[STEP 1]

Graph 3-5:
    +—B0————————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]         |
    |  +--------------+           +-------------+       |
    |  | #1 iload [0] |           | #3 iconst_0 |       |
    |  +--------------+           +-------------+       |
    |         |0                         |0             |
    |  +-----------------------+  +------------------+  |
    |  | #2 iflt B1            |  | #4 STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +------------------+  |
    |  | ATTR:                 |                        |
    |  |  TERMINAL ESCAPE [1]  |                        |
    |  +-----------------------+           +---------+  |
    +——————————————————————————————————————| Next B2 |——+
                                           +---------+

    +—B1—————————————————————+  +—B2—————————————————————+
    |  #SRF Root [0]         |  |  #SRF Root [0]         |
    |  +-------------+       |  |  +------------------+  |
    |  | #5 iconst_1 |       |  |  | #8 STACK RESTORE |  |
    |  +-------------+       |  |  +------------------+  |
    |         |0             |  |         |0             |
    |  +------------------+  |  |  +------------+        |
    |  | #7 STACK BLANK 0 |  |  |  | #6 ireturn |        |
    |  +------------------+  |  |  +------------+        |
    |                        |  +————————————————————————+
    |           +---------+  |
    +———————————| Next B2 |——+
                +---------+ 

Current:
    +--------------+
    | #1 iload [0] |
    +--------------+
           |
          ...

Visited node:
    #1

Bytecode queue:
    #1 iload 0

Transaction table:
    #  BLOCK VISIT [B0] -> [B2]
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;。第一步中，首先将对**块** ```B0``` 的块访问事务推入事务表，由于**块** ```B0``` 存在**下级块**，且为**块** ```B2```，所以将指向**块** ```B2``` 的块访问事务推入事务表顶端。而遍历过程从**根块**即**块** ```B0``` 的第一个**栈相关流根节点**开始，故遍历到 ```#1 iload [0]``` 节点。将其直接加入被还原的字节码队列，并将其标记为已访问。
```
[STEP 2]

Graph 3-5:
    +—B0————————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]         |
    |  +--------------+           +-------------+       |
    |  | #1 iload [0] |           | #3 iconst_0 |       |
    |  +--------------+           +-------------+       |
    |         |0                         |0             |
    |  +-----------------------+  +------------------+  |
    |  | #2 iflt B1            |  | #4 STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +------------------+  |
    |  | ATTR:                 |                        |
    |  |  TERMINAL ESCAPE [1]  |                        |
    |  +-----------------------+           +---------+  |
    +——————————————————————————————————————| Next B2 |——+
                                           +---------+

    +—B1—————————————————————+  +—B2—————————————————————+
    |  #SRF Root [0]         |  |  #SRF Root [0]         |
    |  +-------------+       |  |  +------------------+  |
    |  | #5 iconst_1 |       |  |  | #8 STACK RESTORE |  |
    |  +-------------+       |  |  +------------------+  |
    |         |0             |  |         |0             |
    |  +------------------+  |  |  +------------+        |
    |  | #7 STACK BLANK 0 |  |  |  | #6 ireturn |        |
    |  +------------------+  |  |  +------------+        |
    |                        |  +————————————————————————+
    |           +---------+  |
    +———————————| Next B2 |——+
                +---------+ 

Current:
               ...
                |
    +-----------------------+
    | #2 iflt B1            |
    + - - - - - - - - - - - +
    | ATTR:                 |
    |  TERMINAL ESCAPE [1]  |
    +-----------------------+

Label-Block Map:
    L0 -> B1

Visited node:
    #1, #2

Bytecode queue:
    #1 iload 0
    #2 iflt L0

Transaction table:
    #  BLOCK VISIT [B0] -> [B1]
    #  BLOCK VISIT [B0] -> [B2]
    #  BLOCK VISIT      -> [B0]
```
&emsp;&emsp;第二步中，遍历到了 ```#2 iflt B1``` 节点。该节点是一个跳转指令节点，所以此时需要将其所指向的**块** ```B1``` 推入至事务表顶端，用于保证从**块** ```B0``` 到 **块** ```B1``` 的路径在遍历过程中一定是连通的，同时为**块** ```B1``` 分配一个标签 ```L0```。由于该节点不存在任何未被访问的**上节点**，所以将其直接加入到被还原的字节码队列，并将其标记为已访问。此时已经访问到了**块** ```B0``` 中第 0 号**栈相关流**的结尾，但 ```#2``` 节点中有尾部逃逸属性，并且指向第 1 号**栈相关流**，所以此时将遍历的过程转移至**块** ```B0```中的第 1 号**栈相关流**。
```
[STEP 3]

Graph 3-5:
    +—B0————————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]         |
    |  +--------------+           +-------------+       |
    |  | #1 iload [0] |           | #3 iconst_0 |       |
    |  +--------------+           +-------------+       |
    |         |0                         |0             |
    |  +-----------------------+  +------------------+  |
    |  | #2 iflt B1            |  | #4 STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +------------------+  |
    |  | ATTR:                 |                        |
    |  |  TERMINAL ESCAPE [1]  |                        |
    |  +-----------------------+           +---------+  |
    +——————————————————————————————————————| Next B2 |——+
                                           +---------+

    +—B1—————————————————————+  +—B2—————————————————————+
    |  #SRF Root [0]         |  |  #SRF Root [0]         |
    |  +-------------+       |  |  +------------------+  |
    |  | #5 iconst_1 |       |  |  | #8 STACK RESTORE |  |
    |  +-------------+       |  |  +------------------+  |
    |         |0             |  |         |0             |
    |  +------------------+  |  |  +------------+        |
    |  | #7 STACK BLANK 0 |  |  |  | #6 ireturn |        |
    |  +------------------+  |  |  +------------+        |
    |                        |  +————————————————————————+
    |           +---------+  |
    +———————————| Next B2 |——+
                +---------+ 

Current:
    +-------------+
    | #3 iconst_0 |
    +-------------+
           |
          ...

Label-Block Map:
    L0 -> B1

Visited node:
    #1, #2, #3

Bytecode queue:
    #1 iload 0
    #2 iflt L0
    #3 iconst_0

Transaction table:
    #  BLOCK VISIT [B0] -> [B1]
    #  BLOCK VISIT [B0] -> [B2]
    #  BLOCK VISIT      -> [B0]
```  
&emsp;&emsp;第四步中，遍历过程以及转移到了**块** ```B1``` 的第 1 号**栈相关流**，故遍历到 ```#3 iconst_0``` 节点。将 ```#3``` 节点直接加入到被还原的字节码队列中，并将其标记为已访问。
```
[STEP 4]

Graph 3-5:
    +—B0————————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]         |
    |  +--------------+           +-------------+       |
    |  | #1 iload [0] |           | #3 iconst_0 |       |
    |  +--------------+           +-------------+       |
    |         |0                         |0             |
    |  +-----------------------+  +------------------+  |
    |  | #2 iflt B1            |  | #4 STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +------------------+  |
    |  | ATTR:                 |                        |
    |  |  TERMINAL ESCAPE [1]  |                        |
    |  +-----------------------+           +---------+  |
    +——————————————————————————————————————| Next B2 |——+
                                           +---------+

    +—B1—————————————————————+  +—B2—————————————————————+
    |  #SRF Root [0]         |  |  #SRF Root [0]         |
    |  +-------------+       |  |  +------------------+  |
    |  | #5 iconst_1 |       |  |  | #8 STACK RESTORE |  |
    |  +-------------+       |  |  +------------------+  |
    |         |0             |  |         |0             |
    |  +------------------+  |  |  +------------+        |
    |  | #7 STACK BLANK 0 |  |  |  | #6 ireturn |        |
    |  +------------------+  |  |  +------------+        |
    |                        |  +————————————————————————+
    |           +---------+  |
    +———————————| Next B2 |——+
                +---------+ 

Current:
             ...
              |
    +------------------+
    | #4 STACK BLANK 0 |
    +------------------+

Label-Block Map:
    L0 -> B1
    L1 -> B2

Visited node:
    #1, #2, #3, #4

Visited block:
    B0

Bytecode queue:
    #1 iload 0
    #2 iflt L0
    #3 iconst_0
    #  goto L1

Transaction table:
    #  BLOCK VISIT [B0] -> [B1]
    #  BLOCK VISIT [B0] -> [B2]
```
&emsp;&emsp;第四步中，遍历到了**栈消隐节点** ```#4```，在遍历与还原的过程中该类节点可以被直接忽略，或者可以根据此类节点完成一些 **SRFG** 中跳转时的栈上内容匹配检查。此时对于**块** ```B0``` 的遍历过程已经结束，故将事务表中所有指向**块** ```B0``` 的块访问事务移除。而完成移除后栈顶是一个指向**块** ```B1``` 的块访问事务，故此时将遍历过程转移至**块** ```B1```。同时由于**块** ```B0``` 存在**下级块**，但其为**块** ```B2``` 而并非 **块** ```B1```，所以需要向被还原的字节码队列中添加一个指向**块** ```B2``` 的 ```goto``` 指令，并为**块** ```B2``` 分配一个标签 ```L1```。
```
[STEP 5]

Graph 3-5:
    +—B0————————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]         |
    |  +--------------+           +-------------+       |
    |  | #1 iload [0] |           | #3 iconst_0 |       |
    |  +--------------+           +-------------+       |
    |         |0                         |0             |
    |  +-----------------------+  +------------------+  |
    |  | #2 iflt B1            |  | #4 STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +------------------+  |
    |  | ATTR:                 |                        |
    |  |  TERMINAL ESCAPE [1]  |                        |
    |  +-----------------------+           +---------+  |
    +——————————————————————————————————————| Next B2 |——+
                                           +---------+

    +—B1—————————————————————+  +—B2—————————————————————+
    |  #SRF Root [0]         |  |  #SRF Root [0]         |
    |  +-------------+       |  |  +------------------+  |
    |  | #5 iconst_1 |       |  |  | #8 STACK RESTORE |  |
    |  +-------------+       |  |  +------------------+  |
    |         |0             |  |         |0             |
    |  +------------------+  |  |  +------------+        |
    |  | #7 STACK BLANK 0 |  |  |  | #6 ireturn |        |
    |  +------------------+  |  |  +------------+        |
    |                        |  +————————————————————————+
    |           +---------+  |
    +———————————| Next B2 |——+
                +---------+ 

Current:
    +-------------+
    | #5 iconst_1 |
    +-------------+
           |
          ...

Label-Block Map:
    L0 -> B1
    L1 -> B2

Visited node:
    #1, #2, #3, #4, #5

Visited block:
    B0

Bytecode queue:
    #1 iload 0
    #2 iflt L0
    #3 iconst_0
    #  goto L1
L0: #5 iconst_1

Transaction table:
    #  BLOCK VISIT [B0] -> [B1]
    #  BLOCK VISIT [B0] -> [B2]
```
&emsp;&emsp;第五步中，由于遍历过程已经转移至**块** ```B1```，且**块** ```B1``` 与标签 ```L0``` 相关联，故先将标签 ```L0``` 加入到被还原的字节码队列中。再遍历到了 ```#5 iconst_1``` 节点，将其直接加入被还原的字节码队列，并将其标记为已访问。 
```
[STEP 6]

Graph 3-5:
    +—B0————————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]         |
    |  +--------------+           +-------------+       |
    |  | #1 iload [0] |           | #3 iconst_0 |       |
    |  +--------------+           +-------------+       |
    |         |0                         |0             |
    |  +-----------------------+  +------------------+  |
    |  | #2 iflt B1            |  | #4 STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +------------------+  |
    |  | ATTR:                 |                        |
    |  |  TERMINAL ESCAPE [1]  |                        |
    |  +-----------------------+           +---------+  |
    +——————————————————————————————————————| Next B2 |——+
                                           +---------+

    +—B1—————————————————————+  +—B2—————————————————————+
    |  #SRF Root [0]         |  |  #SRF Root [0]         |
    |  +-------------+       |  |  +------------------+  |
    |  | #5 iconst_1 |       |  |  | #8 STACK RESTORE |  |
    |  +-------------+       |  |  +------------------+  |
    |         |0             |  |         |0             |
    |  +------------------+  |  |  +------------+        |
    |  | #7 STACK BLANK 0 |  |  |  | #6 ireturn |        |
    |  +------------------+  |  |  +------------+        |
    |                        |  +————————————————————————+
    |           +---------+  |
    +———————————| Next B2 |——+
                +---------+ 

Current:
             ...
              |
    +------------------+
    | #7 STACK BLANK 0 |
    +------------------+
    
Label-Block Map:
    L0 -> B1
    L1 -> B2

Visited node:
    #1, #2, #3, #4, #5, #7

Visited block:
    B0, B1

Bytecode queue:
    #1 iload 0
    #2 iflt L0
    #3 iconst_0
    #  goto L1
    #5 iconst_1

Transaction table:
    #  BLOCK VISIT [B1] -> [B2]
    #  BLOCK VISIT [B0] -> [B2]
```
&emsp;&emsp;第六步中，访问到了**栈消隐节点** ```#7```，而该节点没有包含**尾部逃逸**属性，意味着**块** ```B1``` 已经到达了其逻辑尾部，并且该**块**也没有了后续的节点，故**块** ```B1``` 的遍历过程已完成，将其标记为已访问，并将事务表中所有指向**块** ```B1``` 的块访问事务移除。而**块** ```B1``` 的**下级块**为**块** ```B2```，所以此时将一个对**块** ```B2``` 的块访问事务推入事务表顶端，并将遍历过程转移至**块** ```B2```。
```
[STEP 7]

Graph 3-5:
    +—B0————————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]         |
    |  +--------------+           +-------------+       |
    |  | #1 iload [0] |           | #3 iconst_0 |       |
    |  +--------------+           +-------------+       |
    |         |0                         |0             |
    |  +-----------------------+  +------------------+  |
    |  | #2 iflt B1            |  | #4 STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +------------------+  |
    |  | ATTR:                 |                        |
    |  |  TERMINAL ESCAPE [1]  |                        |
    |  +-----------------------+           +---------+  |
    +——————————————————————————————————————| Next B2 |——+
                                           +---------+

    +—B1—————————————————————+  +—B2—————————————————————+
    |  #SRF Root [0]         |  |  #SRF Root [0]         |
    |  +-------------+       |  |  +------------------+  |
    |  | #5 iconst_1 |       |  |  | #8 STACK RESTORE |  |
    |  +-------------+       |  |  +------------------+  |
    |         |0             |  |         |0             |
    |  +------------------+  |  |  +------------+        |
    |  | #7 STACK BLANK 0 |  |  |  | #6 ireturn |        |
    |  +------------------+  |  |  +------------+        |
    |                        |  +————————————————————————+
    |           +---------+  |
    +———————————| Next B2 |——+
                +---------+ 
  
Current:
    +------------------+
    | #8 STACK RESTORE |
    +------------------+
              |
             ... 

Visited node:
    #1, #2, #3, #4, #5, #7, #8

Visited block:
    B0, B1

Bytecode queue:
    #1 iload 0
    #2 iflt L0
    #3 iconst_0
    #  goto L1
    #5 iconst_1

Transaction table:
    #  BLOCK VISIT [B1] -> [B2]
    #  BLOCK VISIT [B0] -> [B2]
```
&emsp;&emsp;第七步中，由于遍历过程已经转移到了**块** ```B2```，故遍历到了**栈恢复节点** ```#8```。在遍历及还原的过程中，不需要对**栈恢复节点**做额外的操作（也可根据该节点检查 **SRFG** 的栈上合法性等），将其标记为已访问即可。
```
[STEP 8]

Graph 3-5:
    +—B0————————————————————————————————————————————————+
    |  #SRF Root [0]              #SRF Root [1]         |
    |  +--------------+           +-------------+       |
    |  | #1 iload [0] |           | #3 iconst_0 |       |
    |  +--------------+           +-------------+       |
    |         |0                         |0             |
    |  +-----------------------+  +------------------+  |
    |  | #2 iflt B1            |  | #4 STACK BLANK 0 |  |
    |  + - - - - - - - - - - - +  +------------------+  |
    |  | ATTR:                 |                        |
    |  |  TERMINAL ESCAPE [1]  |                        |
    |  +-----------------------+           +---------+  |
    +——————————————————————————————————————| Next B2 |——+
                                           +---------+

    +—B1—————————————————————+  +—B2—————————————————————+
    |  #SRF Root [0]         |  |  #SRF Root [0]         |
    |  +-------------+       |  |  +------------------+  |
    |  | #5 iconst_1 |       |  |  | #8 STACK RESTORE |  |
    |  +-------------+       |  |  +------------------+  |
    |         |0             |  |         |0             |
    |  +------------------+  |  |  +------------+        |
    |  | #7 STACK BLANK 0 |  |  |  | #6 ireturn |        |
    |  +------------------+  |  |  +------------+        |
    |                        |  +————————————————————————+
    |           +---------+  |
    +———————————| Next B2 |——+
                +---------+ 

Current:
         ...
          |
    +------------+
    | #6 ireturn |
    +------------+

Visited node:
    #1, #2, #3, #4, #5, #7, #8, #6

Visited block:
    B0, B1, B2

Bytecode queue:
    #1 iload 0
    #2 iflt L0
    #3 iconst_0
    #  goto L1
    #5 iconst_1
    #6 ireturn

Transaction table:
    EMPTY
```
&emsp;&emsp;第八步中，遍历到了 ```#6 ireturn``` 节点，将其直接加入至被还原的字节码队列，并且将其标记为已访问。此时**块** ```B2``` 的遍历过程已经全部结束了，故将其标记为已访问，并将事务表中所有指向**块** ```B2``` 的块访问事务移除。此时，对于图 3-5 所表示的 **SRFG** 的遍历及还原过程就已经全部结束了，以上过程同样可以推广至更复杂的 **SRFG**，更多样例详见 examples 目录。  
    

### <a id = "3-3">3.3&nbsp;修改</a>
&emsp;&emsp;若需要对 **SRFG** 所表示的代码逻辑进行修改，只需要在 **SRFG** 中的指定位置进行插入、删除节点，并保证其结果符合字节码的栈规则与 **SRFG** 的性质规定即可。

#### <a id = "3-3-1">3.3.1&nbsp;逻辑限位</a>
&emsp;&emsp;
  
【未完成】